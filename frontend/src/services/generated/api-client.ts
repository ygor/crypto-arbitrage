//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * Get arbitrage opportunities
     * @param limit (optional) Maximum number of opportunities to return
     * @return A list of arbitrage opportunities
     */
    getArbitrageOpportunities(limit?: number | undefined): Promise<ArbitrageOpportunity[]>;

    /**
     * Get arbitrage trade results
     * @param limit (optional) Maximum number of trades to return
     * @return A list of arbitrage trades
     */
    getArbitrageTrades(limit?: number | undefined): Promise<TradeResult[]>;

    /**
     * Get arbitrage statistics
     * @return Arbitrage system statistics
     */
    getArbitrageStatistics(): Promise<ArbitrageStatistics>;

    /**
     * Get recent arbitrage opportunities
     * @param limit (optional) Maximum number of recent opportunities to return
     * @return A list of recent arbitrage opportunities
     */
    getRecentOpportunities(limit?: number | undefined): Promise<ArbitrageOpportunity[]>;

    /**
     * Get arbitrage opportunities by time range
     * @param start (optional) Start time (ISO 8601 format)
     * @param end (optional) End time (ISO 8601 format)
     * @return A list of arbitrage opportunities
     */
    getOpportunitiesByTimeRange(start?: Date | undefined, end?: Date | undefined): Promise<ArbitrageOpportunity[]>;

    /**
     * Get recent arbitrage trades
     * @param limit (optional) Maximum number of recent trades to return
     * @return A list of recent trades
     */
    getRecentTrades(limit?: number | undefined): Promise<TradeResult[]>;

    /**
     * Get arbitrage trades by time range
     * @param start (optional) Start time (ISO 8601 format)
     * @param end (optional) End time (ISO 8601 format)
     * @return A list of trades
     */
    getTradesByTimeRange(start?: Date | undefined, end?: Date | undefined): Promise<TradeResult[]>;

    /**
     * Get risk profile
     * @return Current risk profile
     */
    getRiskProfile(): Promise<RiskProfile>;

    /**
     * Update risk profile
     * @return Risk profile updated successfully
     */
    updateRiskProfile(body: RiskProfile): Promise<Anonymous>;

    /**
     * Get arbitrage configuration
     * @return Current arbitrage configuration
     */
    getArbitrageConfig(): Promise<ArbitrageConfig>;

    /**
     * Update arbitrage configuration
     * @return Arbitrage configuration updated successfully
     */
    updateArbitrageConfig(body: ArbitrageConfig): Promise<Anonymous2>;

    /**
     * Get exchange configurations
     * @return List of exchange configurations
     */
    getExchangeConfigurations(): Promise<ExchangeConfig[]>;

    /**
     * Update exchange configurations
     * @return Exchange configurations updated successfully
     */
    updateExchangeConfigurations(body: ExchangeConfig[]): Promise<Anonymous3>;

    /**
     * Start the arbitrage bot
     * @return Bot started successfully
     */
    startArbitrageBot(): Promise<Anonymous4>;

    /**
     * Stop the arbitrage bot
     * @return Bot stopped successfully
     */
    stopArbitrageBot(): Promise<Anonymous5>;

    /**
     * Get the status of the arbitrage bot
     * @return Current bot status
     */
    getBotStatus(): Promise<Anonymous6>;

    /**
     * Get general statistics
     * @return General system statistics
     */
    getStatistics(): Promise<ArbitrageStatistics>;

    /**
     * Get bot activity logs
     * @param limit (optional) Maximum number of log entries to return
     * @return A list of activity log entries
     */
    getActivityLogs(limit?: number | undefined): Promise<ActivityLogEntry[]>;

    /**
     * Get exchange status
     * @return Status of all connected exchanges
     */
    getExchangeStatus(): Promise<ExchangeStatus[]>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5001";
    }

    /**
     * Get arbitrage opportunities
     * @param limit (optional) Maximum number of opportunities to return
     * @return A list of arbitrage opportunities
     */
    getArbitrageOpportunities(limit?: number | undefined): Promise<ArbitrageOpportunity[]> {
        let url_ = this.baseUrl + "/api/arbitrage/opportunities?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArbitrageOpportunities(_response);
        });
    }

    protected processGetArbitrageOpportunities(response: Response): Promise<ArbitrageOpportunity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArbitrageOpportunity[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageOpportunity[]>(null as any);
    }

    /**
     * Get arbitrage trade results
     * @param limit (optional) Maximum number of trades to return
     * @return A list of arbitrage trades
     */
    getArbitrageTrades(limit?: number | undefined): Promise<TradeResult[]> {
        let url_ = this.baseUrl + "/api/arbitrage/trades?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArbitrageTrades(_response);
        });
    }

    protected processGetArbitrageTrades(response: Response): Promise<TradeResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TradeResult[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TradeResult[]>(null as any);
    }

    /**
     * Get arbitrage statistics
     * @return Arbitrage system statistics
     */
    getArbitrageStatistics(): Promise<ArbitrageStatistics> {
        let url_ = this.baseUrl + "/api/arbitrage/statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArbitrageStatistics(_response);
        });
    }

    protected processGetArbitrageStatistics(response: Response): Promise<ArbitrageStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArbitrageStatistics;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageStatistics>(null as any);
    }

    /**
     * Get recent arbitrage opportunities
     * @param limit (optional) Maximum number of recent opportunities to return
     * @return A list of recent arbitrage opportunities
     */
    getRecentOpportunities(limit?: number | undefined): Promise<ArbitrageOpportunity[]> {
        let url_ = this.baseUrl + "/api/opportunities/recent?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecentOpportunities(_response);
        });
    }

    protected processGetRecentOpportunities(response: Response): Promise<ArbitrageOpportunity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArbitrageOpportunity[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageOpportunity[]>(null as any);
    }

    /**
     * Get arbitrage opportunities by time range
     * @param start (optional) Start time (ISO 8601 format)
     * @param end (optional) End time (ISO 8601 format)
     * @return A list of arbitrage opportunities
     */
    getOpportunitiesByTimeRange(start?: Date | undefined, end?: Date | undefined): Promise<ArbitrageOpportunity[]> {
        let url_ = this.baseUrl + "/api/opportunities?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOpportunitiesByTimeRange(_response);
        });
    }

    protected processGetOpportunitiesByTimeRange(response: Response): Promise<ArbitrageOpportunity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArbitrageOpportunity[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid date format", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageOpportunity[]>(null as any);
    }

    /**
     * Get recent arbitrage trades
     * @param limit (optional) Maximum number of recent trades to return
     * @return A list of recent trades
     */
    getRecentTrades(limit?: number | undefined): Promise<TradeResult[]> {
        let url_ = this.baseUrl + "/api/trades/recent?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecentTrades(_response);
        });
    }

    protected processGetRecentTrades(response: Response): Promise<TradeResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TradeResult[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TradeResult[]>(null as any);
    }

    /**
     * Get arbitrage trades by time range
     * @param start (optional) Start time (ISO 8601 format)
     * @param end (optional) End time (ISO 8601 format)
     * @return A list of trades
     */
    getTradesByTimeRange(start?: Date | undefined, end?: Date | undefined): Promise<TradeResult[]> {
        let url_ = this.baseUrl + "/api/trades?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTradesByTimeRange(_response);
        });
    }

    protected processGetTradesByTimeRange(response: Response): Promise<TradeResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TradeResult[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid date format", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TradeResult[]>(null as any);
    }

    /**
     * Get risk profile
     * @return Current risk profile
     */
    getRiskProfile(): Promise<RiskProfile> {
        let url_ = this.baseUrl + "/api/settings/risk-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRiskProfile(_response);
        });
    }

    protected processGetRiskProfile(response: Response): Promise<RiskProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RiskProfile;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RiskProfile>(null as any);
    }

    /**
     * Update risk profile
     * @return Risk profile updated successfully
     */
    updateRiskProfile(body: RiskProfile): Promise<Anonymous> {
        let url_ = this.baseUrl + "/api/settings/risk-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRiskProfile(_response);
        });
    }

    protected processUpdateRiskProfile(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    /**
     * Get arbitrage configuration
     * @return Current arbitrage configuration
     */
    getArbitrageConfig(): Promise<ArbitrageConfig> {
        let url_ = this.baseUrl + "/api/settings/arbitrage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArbitrageConfig(_response);
        });
    }

    protected processGetArbitrageConfig(response: Response): Promise<ArbitrageConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArbitrageConfig;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageConfig>(null as any);
    }

    /**
     * Update arbitrage configuration
     * @return Arbitrage configuration updated successfully
     */
    updateArbitrageConfig(body: ArbitrageConfig): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/api/settings/arbitrage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateArbitrageConfig(_response);
        });
    }

    protected processUpdateArbitrageConfig(response: Response): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous2;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous2>(null as any);
    }

    /**
     * Get exchange configurations
     * @return List of exchange configurations
     */
    getExchangeConfigurations(): Promise<ExchangeConfig[]> {
        let url_ = this.baseUrl + "/api/settings/exchanges";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExchangeConfigurations(_response);
        });
    }

    protected processGetExchangeConfigurations(response: Response): Promise<ExchangeConfig[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExchangeConfig[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExchangeConfig[]>(null as any);
    }

    /**
     * Update exchange configurations
     * @return Exchange configurations updated successfully
     */
    updateExchangeConfigurations(body: ExchangeConfig[]): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/api/settings/exchanges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateExchangeConfigurations(_response);
        });
    }

    protected processUpdateExchangeConfigurations(response: Response): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous3;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous3>(null as any);
    }

    /**
     * Start the arbitrage bot
     * @return Bot started successfully
     */
    startArbitrageBot(): Promise<Anonymous4> {
        let url_ = this.baseUrl + "/api/settings/bot/start";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartArbitrageBot(_response);
        });
    }

    protected processStartArbitrageBot(response: Response): Promise<Anonymous4> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous4;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous4>(null as any);
    }

    /**
     * Stop the arbitrage bot
     * @return Bot stopped successfully
     */
    stopArbitrageBot(): Promise<Anonymous5> {
        let url_ = this.baseUrl + "/api/settings/bot/stop";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStopArbitrageBot(_response);
        });
    }

    protected processStopArbitrageBot(response: Response): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous5;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous5>(null as any);
    }

    /**
     * Get the status of the arbitrage bot
     * @return Current bot status
     */
    getBotStatus(): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/api/settings/bot/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBotStatus(_response);
        });
    }

    protected processGetBotStatus(response: Response): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous6;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous6>(null as any);
    }

    /**
     * Get general statistics
     * @return General system statistics
     */
    getStatistics(): Promise<ArbitrageStatistics> {
        let url_ = this.baseUrl + "/api/statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatistics(_response);
        });
    }

    protected processGetStatistics(response: Response): Promise<ArbitrageStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArbitrageStatistics;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArbitrageStatistics>(null as any);
    }

    /**
     * Get bot activity logs
     * @param limit (optional) Maximum number of log entries to return
     * @return A list of activity log entries
     */
    getActivityLogs(limit?: number | undefined): Promise<ActivityLogEntry[]> {
        let url_ = this.baseUrl + "/api/settings/bot/activity-logs?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivityLogs(_response);
        });
    }

    protected processGetActivityLogs(response: Response): Promise<ActivityLogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActivityLogEntry[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityLogEntry[]>(null as any);
    }

    /**
     * Get exchange status
     * @return Status of all connected exchanges
     */
    getExchangeStatus(): Promise<ExchangeStatus[]> {
        let url_ = this.baseUrl + "/api/settings/bot/exchange-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExchangeStatus(_response);
        });
    }

    protected processGetExchangeStatus(response: Response): Promise<ExchangeStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExchangeStatus[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExchangeStatus[]>(null as any);
    }
}

export interface TradingPair {
    baseCurrency: string;
    quoteCurrency: string;

    [key: string]: any;
}

export interface ArbitrageOpportunity {
    id?: string;
    tradingPair?: TradingPair;
    buyExchangeId?: string;
    sellExchangeId?: string;
    buyPrice?: number;
    sellPrice?: number;
    quantity?: number;
    timestamp?: Date;
    /** 0=Detected, 1=Executing, 2=Executed, 3=Failed, 4=Missed */
    status?: ArbitrageOpportunityStatus;
    potentialProfit?: number;
    spreadPercentage?: number;
    estimatedProfit?: number;
    detectedAt?: Date;
    spread?: number;
    effectiveQuantity?: number;
    isQualified?: boolean;

    [key: string]: any;
}

export interface TradeResult {
    id?: string;
    opportunityId?: string;
    tradingPair?: TradingPair;
    buyExchangeId?: string;
    sellExchangeId?: string;
    buyPrice?: number;
    sellPrice?: number;
    quantity?: number;
    timestamp?: Date;
    /** 0=Pending, 1=Executing, 2=Completed, 3=Failed */
    status?: TradeResultStatus;
    profitAmount?: number;
    profitPercentage?: number;
    fees?: number;
    executionTimeMs?: number;

    [key: string]: any;
}

export interface ArbitrageStatistics {
    startTime?: Date;
    endTime?: Date;
    totalProfit?: number;
    totalVolume?: number;
    totalFees?: number;
    averageProfit?: number;
    highestProfit?: number;
    lowestProfit?: number;
    totalOpportunitiesDetected?: number;
    totalTradesExecuted?: number;
    successfulTrades?: number;
    failedTrades?: number;
    averageExecutionTimeMs?: number;
    profitFactor?: number;

    [key: string]: any;
}

export interface RiskProfile {
    name?: string;
    isActive?: boolean;
    minProfitPercentage?: number;
    minProfitAmount?: number;
    minimumProfitPercentage?: number;
    maxSlippagePercentage?: number;
    riskTolerance?: number;
    maxRetryAttempts?: number;
    maxSpreadVolatility?: number;
    stopLossPercentage?: number;
    dailyLossLimitPercent?: number;
    usePriceProtection?: boolean;
    maxTradeAmount?: number;
    maxAssetExposurePercentage?: number;
    maxTotalExposurePercentage?: number;
    dynamicSizingFactor?: number;
    maxCapitalPerTradePercent?: number;
    maxCapitalPerAssetPercent?: number;
    executionAggressiveness?: number;
    maxExecutionTimeMs?: number;
    orderBookDepthFactor?: number;
    cooldownPeriodMs?: number;
    maxConcurrentTrades?: number;
    tradeCooldownMs?: number;
    useAdaptiveParameters?: boolean;

    [key: string]: any;
}

export interface ArbitrageConfig {
    isEnabled?: boolean;
    enabledTradingPairs?: string[];
    enabledBaseCurrencies?: string[];
    enabledQuoteCurrencies?: string[];
    enabledExchanges?: string[];
    enabledExchangePairs?: ExchangePair[];
    scanIntervalMs?: number;
    maxConcurrentScans?: number;
    autoTradeEnabled?: boolean;
    maxDailyTrades?: number;
    maxDailyVolume?: number;
    minOrderBookDepth?: number;
    useWebsockets?: boolean;
    usePolling?: boolean;
    pollingIntervalMs?: number;
    evaluationStrategy?: ArbitrageConfigEvaluationStrategy;
    executionStrategy?: ArbitrageConfigExecutionStrategy;

    [key: string]: any;
}

export interface ExchangePair {
    buyExchangeId: string;
    sellExchangeId: string;

    [key: string]: any;
}

export interface ExchangeConfig {
    exchangeId: string;
    name?: string;
    isEnabled: boolean;
    apiKey?: string;
    apiSecret?: string;
    maxRequestsPerSecond?: number;

    [key: string]: any;
}

export interface ActivityLogEntry {
    id: string;
    timestamp: Date;
    type: ActivityLogEntryType;
    message: string;
    details?: string;
    relatedEntityId?: string;
    relatedEntityType?: string;

    [key: string]: any;
}

export interface ExchangeStatus {
    exchangeId: string;
    exchangeName: string;
    isUp: boolean;
    lastChecked: Date;
    responseTimeMs: number;
    additionalInfo?: string;

    [key: string]: any;
}

export interface Anonymous {
    message?: string;

    [key: string]: any;
}

export interface Anonymous2 {
    message?: string;

    [key: string]: any;
}

export interface Anonymous3 {
    message?: string;

    [key: string]: any;
}

export interface Anonymous4 {
    message?: string;

    [key: string]: any;
}

export interface Anonymous5 {
    message?: string;

    [key: string]: any;
}

export interface Anonymous6 {
    isRunning?: boolean;

    [key: string]: any;
}

export enum ArbitrageOpportunityStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum TradeResultStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum ArbitrageConfigEvaluationStrategy {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum ArbitrageConfigExecutionStrategy {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum ActivityLogEntryType {
    Info = "Info",
    Warning = "Warning",
    Error = "Error",
    Success = "Success",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}